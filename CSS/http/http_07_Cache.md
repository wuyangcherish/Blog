# 07 Cache 缓存

### 缓存的优点

####  1. 减少了冗余的数据的传输，节省网络费用。

一遍遍的请求相同的数据，会耗尽昂贵的网络带宽，降低传输的数据。但是如果将第一条服务期相应的数据保留为副本，后继请求就可以由缓存的副本来应对了。这样可以减少浪费掉的流量。

####  2. 缓解网络瓶颈的问题，不需要更多的带宽就能够更快的加载页面。

很多网络为本地客户端提供的带宽比为远程服务器提供的带宽要宽。所以从一个局域网的缓存中取数据要更快一些

####  3. 降低了对原始服务器的要求，服务器可以更快的响应，避免过载的出现。

爆炸性新闻，批量 E-mail 公告，或者某个名人事件, 使得很多人几乎同时去访问一个web文档时，就会出现瞬间拥塞,由此造成的过多的流量峰值可能会使得网络和Web服务器产生崩溃。

4. 降低了距离时延。



### 关于缓存

#### 1. 命中与未命中

用已有的副本为某些到达缓存的请求提供服务，成为 ``缓存命中``  其他一些到达缓存的请求但是没有副本可用，而被转发给原始的服务器的，被称为 ``缓存未命中``。

#### 2. 再验证

由于原始的服务器内容会不断地发生着变化，缓存要时不时的进行检测，看看保留在缓存的副本是不是最新的。 这个“新鲜度检测”的过程称为``HTTP再验证`` 为了有效地进行验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。

讲道理的话，缓存是可以在任意的时刻进行再验证的。但是网络带宽是很珍贵的，所以一般情况下是在**客户端发起请求，并且副本已经旧的足以需要检测**的时候才进行再验证操作。

缓存对缓存的副本进行再验证的时候，会向原始的服务器放送一个小的再验证请求。 如果内容没有变化， 则服务器返回一个小的**304 Not Modified** 进行响应。然后缓存继续将副本标记为暂时新鲜的，并且提供给客户端。这称为``再验证命中`` 或 ``缓慢命中`` 。如果对象已于副本不同，那么返回一条**HTTP 200 OK**响应，对副本的内容进行更新。如果该对象已经被删除，则返回一个**404 Not Found**的响应，缓存也将被删除。

HTTP提供的几个用来对已缓存对象进行再验证的工具，最常见的是用 **If-Modified-Since** 首部。这个首部添加到GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。 

#### 3. 命中率

由缓存提供服务的请求所占的比例称为**缓存命中率（cache hit rate）** 在0~1之间，命中率由 缓存用户兴趣点的相似性,缓存数据的变化和个性化频率，以及如何配置缓存有关。对于中等规模的 Web缓存来说，40% 的命中率是很合理的。足以减少流量了。

#### 4. 字节命中率

是缓存提供的字节在传输的所有字节中所占的比例。计算时候可得到节省流量的程度。文档的命中率说明了阻止了通往外部网络的Web事务。事务有一个通常都很大固定成分（比如建立一条到服务器的TCP连接）提高文档命中率对于降低整体延时很有好处。

####  5. 缓存的拓扑结构

1. 私有缓存

Web浏览器有自建的私有缓存，--大多数浏览器都会将常用的文档缓存到个人电脑的磁盘中和内存中。并且允许用户去配置缓存的大小等，

2. 共有缓存

是特殊的共享代理服务器，被称为``代理缓存``，他会从本地缓存中提供文档，或者代表用户和服务器进行联系。可以接接受多个用户的访问。

共有缓存要缓存用户群体中各种不同的兴趣点，所以要足够的大才能承载常用的文档集，而不会被单个用户占满。

#### 6. 缓存的处理步骤

1. 接收 -- 缓存从网络中读取抵达的请求报文
2. 解析 -- 缓存对报文进行解析，提取出 URL 和各种首部
3. 查询 -- 缓存查看是否有本地副本可用，如果没有则获取一份副本并保存在本地
4. 新鲜度检查 -- 缓存查看已缓存副本是否足都新鲜，如果不是，就查询服务器是否有任何的更新。
5. 创建响应 -- 缓存会用新的首部和已缓存的主题来构建一条响应报文。
6. 发送 -- 缓存通过网络将响应发回给客户端
7. 日志 -- 缓存可选地创建一个日志条目来描述这个事物

#### 7. 保持副本的新鲜

HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据已服务器数据值之间充分一致。这些机制称为``文档过期`` 和 ``服务器再验证``。

1. 文档过期

通过 HTTP Cache-Control 首部和 expires 首部， HTTP 为每个文档加上了一个过期的时间。 一旦超过这个日期，缓存就必须与服务器进行核对，查询文档是否被修改过。如果被修改则更新旧得副本。

Cache-Control: max-age -> 制定一个最大的使用期限。
Expires:Fri,05 Jul.... -> 指定的是一个绝对的过期日期

更倾向于使用第一种。

2. 服务器再验证

用来查询原始的服务器看看文档是否发生了变化

3. 什么时候用实体标签和最近修改日期

如果服务器回送了一个实体标签， HTTP/1.1 客户端就必须使用实体标签验证器。 

如果服务器只是返回了一个 Last-Modified 值，客户端就可以使用If-Modified-Since 验证。

如果两种方式都提供了，那么客户端就应该使用这两种再验证方案，


#### 8. 控制缓存的能力

##### no-Store 和 no-Cache 响应首部

```
	pragma: no-cache
	Cache-Control: no-store
	Cache-Control: no-cache
```

标识为 **no-store** 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 **no-store** 响应，然后删除对象。也就是说代理缓存的服务器不起作用，每次还是向原始服务器进行请求的

标识为 **no-chache** 的响应实际上是可以存储在本地缓存中的，只是在与原始的服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。也就是 **do-not-serve-from-cache-without-revalidation** 这个的话就是说可是使用缓存，但是每次客户端请求之后，代理缓存必须先向原始服务器查看下缓存是否过期，之后才可使用。

**Pragma: no-cache** 首部是为了兼容 HTTP/1.0+.


##### max-age 响应首部

Cache-Control: max-age 首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个s-maxage 首部，其行为与max-age 类似，但仅限于共享缓存

如果服务器可以请求缓存不要缓存文档，则将使用期限设置为0 即可

##### Expires 响应首部

指定的是过期的日期而不是秒数，但是由于很多服务器的时钟都不统一，或者不正确，所以不太推荐使用。

##### must-revalidate 响应首部

可以配置缓存，使其提供一些陈旧（过期）的对象。以提高性能。

如果原始服务器希望缓存可以严格的遵守过期信息， 可以在原始的响应中附加一个 **Cache-Control: must-revalidate** 

在事先没有跟原始的服务器进行再验证的情况下，不能提供这个对象的陈旧副本。 缓存仍然可以随意提供新鲜的副本， 如果在缓存进行**must-revalidate** 新鲜度检查的时候,原始服务器不可用，缓存就必须返回一条** 504 Cateway Timeout** 错误

##### 试探性过期

在响应中没有 **Cache-Control:max-age**首部 也没有**Expires** 首部，缓存可以计算出一个试探性最大使用期。

**LM-Factor** 算法是一种很常用的试探性过期算法.